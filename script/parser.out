Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> proc
Rule 1     proc -> proc com
Rule 2     proc -> com
Rule 3     com -> { proc }
Rule 4     com -> if
Rule 5     if -> IF ( expr ) com ELSE com
Rule 6     if -> IF ( expr ) com
Rule 7     com -> WHILE ( expr ) com
Rule 8     com -> UNTIL ( expr ) com
Rule 9     com -> FOR ( cexpr cexpr expr ) com
Rule 10    com -> DEFINE ID ( call ) com
Rule 11    com -> cexpr
Rule 12    com -> ;
Rule 13    cexpr -> expr ;
Rule 14    expr -> substitute
Rule 15    substitute -> substitute SET logical
Rule 16    substitute -> substitute AAS logical
Rule 17    substitute -> substitute SAS logical
Rule 18    substitute -> substitute MAS logical
Rule 19    substitute -> substitute DAS logical
Rule 20    substitute -> substitute RAS logical
Rule 21    substitute -> substitute SQS logical
Rule 22    substitute -> logical
Rule 23    logical -> logical & comparison
Rule 24    logical -> logical | comparison
Rule 25    logical -> ! comparison
Rule 26    logical -> comparison
Rule 27    comparison -> comparison EQU polynomial
Rule 28    comparison -> comparison BOE polynomial
Rule 29    comparison -> comparison SOE polynomial
Rule 30    comparison -> comparison NOE polynomial
Rule 31    comparison -> comparison BIG polynomial
Rule 32    comparison -> comparison SMA polynomial
Rule 33    comparison -> polynomial
Rule 34    polynomial -> polynomial + factor
Rule 35    polynomial -> polynomial - factor
Rule 36    polynomial -> factor
Rule 37    factor -> factor * element
Rule 38    factor -> factor / element
Rule 39    factor -> factor % element
Rule 40    factor -> element ^ factor
Rule 41    factor -> element
Rule 42    element -> BREAK
Rule 43    element -> CONTINUE
Rule 44    element -> - NUMBER
Rule 45    element -> NUMBER
Rule 46    element -> TRUE
Rule 47    element -> FALSE
Rule 48    element -> STRING
Rule 49    element -> ID ( call )
Rule 50    element -> ID
Rule 51    element -> { call }
Rule 52    element -> ID index
Rule 53    index -> index [ expr ]
Rule 54    index -> [ expr ]
Rule 55    element -> ( expr )
Rule 56    call -> call , expr
Rule 57    call -> expr
Rule 58    call -> <empty>

Terminals, with rules where they appear

!                    : 25
%                    : 39
&                    : 23
(                    : 5 6 7 8 9 10 49 55
)                    : 5 6 7 8 9 10 49 55
*                    : 37
+                    : 34
,                    : 56
-                    : 35 44
/                    : 38
;                    : 12 13
AAS                  : 16
BIG                  : 31
BOE                  : 28
BREAK                : 42
COMMENT              : 
CONTINUE             : 43
DAS                  : 19
DEFINE               : 10
ELSE                 : 5
EQU                  : 27
FALSE                : 47
FOR                  : 9
ID                   : 10 49 50 52
IF                   : 5 6
MAS                  : 18
NOE                  : 30
NUMBER               : 44 45
RAS                  : 20
SAS                  : 17
SET                  : 15
SMA                  : 32
SOE                  : 29
SQS                  : 21
STRING               : 48
TRUE                 : 46
UNTIL                : 8
WHILE                : 7
[                    : 53 54
]                    : 53 54
^                    : 40
error                : 
{                    : 3 51
|                    : 24
}                    : 3 51

Nonterminals, with rules where they appear

call                 : 10 49 51 56
cexpr                : 9 9 11
com                  : 1 2 5 5 6 7 8 9 10
comparison           : 23 24 25 26 27 28 29 30 31 32
element              : 37 38 39 40 41
expr                 : 5 6 7 8 9 13 53 54 55 56 57
factor               : 34 35 36 37 38 39 40
if                   : 4
index                : 52 53
logical              : 15 16 17 18 19 20 21 22 23 24
polynomial           : 27 28 29 30 31 32 33 34 35
proc                 : 1 3 0
substitute           : 14 15 16 17 18 19 20 21

Parsing method: LALR

state 0

    (0) S' -> . proc
    (1) proc -> . proc com
    (2) proc -> . com
    (3) com -> . { proc }
    (4) com -> . if
    (7) com -> . WHILE ( expr ) com
    (8) com -> . UNTIL ( expr ) com
    (9) com -> . FOR ( cexpr cexpr expr ) com
    (10) com -> . DEFINE ID ( call ) com
    (11) com -> . cexpr
    (12) com -> . ;
    (5) if -> . IF ( expr ) com ELSE com
    (6) if -> . IF ( expr ) com
    (13) cexpr -> . expr ;
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    {               shift and go to state 3
    WHILE           shift and go to state 5
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    DEFINE          shift and go to state 11
    ;               shift and go to state 13
    IF              shift and go to state 14
    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    (               shift and go to state 6

    proc                           shift and go to state 1
    com                            shift and go to state 2
    if                             shift and go to state 4
    expr                           shift and go to state 7
    cexpr                          shift and go to state 10
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 1

    (0) S' -> proc .
    (1) proc -> proc . com
    (3) com -> . { proc }
    (4) com -> . if
    (7) com -> . WHILE ( expr ) com
    (8) com -> . UNTIL ( expr ) com
    (9) com -> . FOR ( cexpr cexpr expr ) com
    (10) com -> . DEFINE ID ( call ) com
    (11) com -> . cexpr
    (12) com -> . ;
    (5) if -> . IF ( expr ) com ELSE com
    (6) if -> . IF ( expr ) com
    (13) cexpr -> . expr ;
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    {               shift and go to state 3
    WHILE           shift and go to state 5
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    DEFINE          shift and go to state 11
    ;               shift and go to state 13
    IF              shift and go to state 14
    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    (               shift and go to state 6

    com                            shift and go to state 29
    if                             shift and go to state 4
    expr                           shift and go to state 7
    cexpr                          shift and go to state 10
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 2

    (2) proc -> com .

    {               reduce using rule 2 (proc -> com .)
    WHILE           reduce using rule 2 (proc -> com .)
    UNTIL           reduce using rule 2 (proc -> com .)
    FOR             reduce using rule 2 (proc -> com .)
    DEFINE          reduce using rule 2 (proc -> com .)
    ;               reduce using rule 2 (proc -> com .)
    IF              reduce using rule 2 (proc -> com .)
    !               reduce using rule 2 (proc -> com .)
    BREAK           reduce using rule 2 (proc -> com .)
    CONTINUE        reduce using rule 2 (proc -> com .)
    -               reduce using rule 2 (proc -> com .)
    NUMBER          reduce using rule 2 (proc -> com .)
    TRUE            reduce using rule 2 (proc -> com .)
    FALSE           reduce using rule 2 (proc -> com .)
    STRING          reduce using rule 2 (proc -> com .)
    ID              reduce using rule 2 (proc -> com .)
    (               reduce using rule 2 (proc -> com .)
    $end            reduce using rule 2 (proc -> com .)
    }               reduce using rule 2 (proc -> com .)


state 3

    (3) com -> { . proc }
    (51) element -> { . call }
    (1) proc -> . proc com
    (2) proc -> . com
    (56) call -> . call , expr
    (57) call -> . expr
    (58) call -> .
    (3) com -> . { proc }
    (4) com -> . if
    (7) com -> . WHILE ( expr ) com
    (8) com -> . UNTIL ( expr ) com
    (9) com -> . FOR ( cexpr cexpr expr ) com
    (10) com -> . DEFINE ID ( call ) com
    (11) com -> . cexpr
    (12) com -> . ;
    (14) expr -> . substitute
    (5) if -> . IF ( expr ) com ELSE com
    (6) if -> . IF ( expr ) com
    (13) cexpr -> . expr ;
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    }               reduce using rule 58 (call -> .)
    ,               reduce using rule 58 (call -> .)
    {               shift and go to state 3
    WHILE           shift and go to state 5
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    DEFINE          shift and go to state 11
    ;               shift and go to state 13
    IF              shift and go to state 14
    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    (               shift and go to state 6

    proc                           shift and go to state 30
    call                           shift and go to state 31
    com                            shift and go to state 2
    expr                           shift and go to state 32
    if                             shift and go to state 4
    cexpr                          shift and go to state 10
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 4

    (4) com -> if .

    {               reduce using rule 4 (com -> if .)
    WHILE           reduce using rule 4 (com -> if .)
    UNTIL           reduce using rule 4 (com -> if .)
    FOR             reduce using rule 4 (com -> if .)
    DEFINE          reduce using rule 4 (com -> if .)
    ;               reduce using rule 4 (com -> if .)
    IF              reduce using rule 4 (com -> if .)
    !               reduce using rule 4 (com -> if .)
    BREAK           reduce using rule 4 (com -> if .)
    CONTINUE        reduce using rule 4 (com -> if .)
    -               reduce using rule 4 (com -> if .)
    NUMBER          reduce using rule 4 (com -> if .)
    TRUE            reduce using rule 4 (com -> if .)
    FALSE           reduce using rule 4 (com -> if .)
    STRING          reduce using rule 4 (com -> if .)
    ID              reduce using rule 4 (com -> if .)
    (               reduce using rule 4 (com -> if .)
    $end            reduce using rule 4 (com -> if .)
    }               reduce using rule 4 (com -> if .)
    ELSE            reduce using rule 4 (com -> if .)


state 5

    (7) com -> WHILE . ( expr ) com

    (               shift and go to state 33


state 6

    (55) element -> ( . expr )
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    expr                           shift and go to state 34
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 7

    (13) cexpr -> expr . ;

    ;               shift and go to state 36


state 8

    (8) com -> UNTIL . ( expr ) com

    (               shift and go to state 37


state 9

    (9) com -> FOR . ( cexpr cexpr expr ) com

    (               shift and go to state 38


state 10

    (11) com -> cexpr .

    {               reduce using rule 11 (com -> cexpr .)
    WHILE           reduce using rule 11 (com -> cexpr .)
    UNTIL           reduce using rule 11 (com -> cexpr .)
    FOR             reduce using rule 11 (com -> cexpr .)
    DEFINE          reduce using rule 11 (com -> cexpr .)
    ;               reduce using rule 11 (com -> cexpr .)
    IF              reduce using rule 11 (com -> cexpr .)
    !               reduce using rule 11 (com -> cexpr .)
    BREAK           reduce using rule 11 (com -> cexpr .)
    CONTINUE        reduce using rule 11 (com -> cexpr .)
    -               reduce using rule 11 (com -> cexpr .)
    NUMBER          reduce using rule 11 (com -> cexpr .)
    TRUE            reduce using rule 11 (com -> cexpr .)
    FALSE           reduce using rule 11 (com -> cexpr .)
    STRING          reduce using rule 11 (com -> cexpr .)
    ID              reduce using rule 11 (com -> cexpr .)
    (               reduce using rule 11 (com -> cexpr .)
    $end            reduce using rule 11 (com -> cexpr .)
    }               reduce using rule 11 (com -> cexpr .)
    ELSE            reduce using rule 11 (com -> cexpr .)


state 11

    (10) com -> DEFINE . ID ( call ) com

    ID              shift and go to state 39


state 12

    (49) element -> ID . ( call )
    (50) element -> ID .
    (52) element -> ID . index
    (53) index -> . index [ expr ]
    (54) index -> . [ expr ]

    (               shift and go to state 40
    ^               reduce using rule 50 (element -> ID .)
    *               reduce using rule 50 (element -> ID .)
    /               reduce using rule 50 (element -> ID .)
    %               reduce using rule 50 (element -> ID .)
    +               reduce using rule 50 (element -> ID .)
    -               reduce using rule 50 (element -> ID .)
    EQU             reduce using rule 50 (element -> ID .)
    BOE             reduce using rule 50 (element -> ID .)
    SOE             reduce using rule 50 (element -> ID .)
    NOE             reduce using rule 50 (element -> ID .)
    BIG             reduce using rule 50 (element -> ID .)
    SMA             reduce using rule 50 (element -> ID .)
    &               reduce using rule 50 (element -> ID .)
    |               reduce using rule 50 (element -> ID .)
    SET             reduce using rule 50 (element -> ID .)
    AAS             reduce using rule 50 (element -> ID .)
    SAS             reduce using rule 50 (element -> ID .)
    MAS             reduce using rule 50 (element -> ID .)
    DAS             reduce using rule 50 (element -> ID .)
    RAS             reduce using rule 50 (element -> ID .)
    SQS             reduce using rule 50 (element -> ID .)
    ;               reduce using rule 50 (element -> ID .)
    }               reduce using rule 50 (element -> ID .)
    ,               reduce using rule 50 (element -> ID .)
    )               reduce using rule 50 (element -> ID .)
    ]               reduce using rule 50 (element -> ID .)
    [               shift and go to state 42

    index                          shift and go to state 41

state 13

    (12) com -> ; .

    {               reduce using rule 12 (com -> ; .)
    WHILE           reduce using rule 12 (com -> ; .)
    UNTIL           reduce using rule 12 (com -> ; .)
    FOR             reduce using rule 12 (com -> ; .)
    DEFINE          reduce using rule 12 (com -> ; .)
    ;               reduce using rule 12 (com -> ; .)
    IF              reduce using rule 12 (com -> ; .)
    !               reduce using rule 12 (com -> ; .)
    BREAK           reduce using rule 12 (com -> ; .)
    CONTINUE        reduce using rule 12 (com -> ; .)
    -               reduce using rule 12 (com -> ; .)
    NUMBER          reduce using rule 12 (com -> ; .)
    TRUE            reduce using rule 12 (com -> ; .)
    FALSE           reduce using rule 12 (com -> ; .)
    STRING          reduce using rule 12 (com -> ; .)
    ID              reduce using rule 12 (com -> ; .)
    (               reduce using rule 12 (com -> ; .)
    $end            reduce using rule 12 (com -> ; .)
    }               reduce using rule 12 (com -> ; .)
    ELSE            reduce using rule 12 (com -> ; .)


state 14

    (5) if -> IF . ( expr ) com ELSE com
    (6) if -> IF . ( expr ) com

    (               shift and go to state 43


state 15

    (14) expr -> substitute .
    (15) substitute -> substitute . SET logical
    (16) substitute -> substitute . AAS logical
    (17) substitute -> substitute . SAS logical
    (18) substitute -> substitute . MAS logical
    (19) substitute -> substitute . DAS logical
    (20) substitute -> substitute . RAS logical
    (21) substitute -> substitute . SQS logical

    ;               reduce using rule 14 (expr -> substitute .)
    }               reduce using rule 14 (expr -> substitute .)
    ,               reduce using rule 14 (expr -> substitute .)
    )               reduce using rule 14 (expr -> substitute .)
    ]               reduce using rule 14 (expr -> substitute .)
    SET             shift and go to state 44
    AAS             shift and go to state 45
    SAS             shift and go to state 46
    MAS             shift and go to state 47
    DAS             shift and go to state 48
    RAS             shift and go to state 49
    SQS             shift and go to state 50


state 16

    (22) substitute -> logical .
    (23) logical -> logical . & comparison
    (24) logical -> logical . | comparison

    SET             reduce using rule 22 (substitute -> logical .)
    AAS             reduce using rule 22 (substitute -> logical .)
    SAS             reduce using rule 22 (substitute -> logical .)
    MAS             reduce using rule 22 (substitute -> logical .)
    DAS             reduce using rule 22 (substitute -> logical .)
    RAS             reduce using rule 22 (substitute -> logical .)
    SQS             reduce using rule 22 (substitute -> logical .)
    ;               reduce using rule 22 (substitute -> logical .)
    }               reduce using rule 22 (substitute -> logical .)
    ,               reduce using rule 22 (substitute -> logical .)
    )               reduce using rule 22 (substitute -> logical .)
    ]               reduce using rule 22 (substitute -> logical .)
    &               shift and go to state 51
    |               shift and go to state 52


state 17

    (26) logical -> comparison .
    (27) comparison -> comparison . EQU polynomial
    (28) comparison -> comparison . BOE polynomial
    (29) comparison -> comparison . SOE polynomial
    (30) comparison -> comparison . NOE polynomial
    (31) comparison -> comparison . BIG polynomial
    (32) comparison -> comparison . SMA polynomial

    &               reduce using rule 26 (logical -> comparison .)
    |               reduce using rule 26 (logical -> comparison .)
    SET             reduce using rule 26 (logical -> comparison .)
    AAS             reduce using rule 26 (logical -> comparison .)
    SAS             reduce using rule 26 (logical -> comparison .)
    MAS             reduce using rule 26 (logical -> comparison .)
    DAS             reduce using rule 26 (logical -> comparison .)
    RAS             reduce using rule 26 (logical -> comparison .)
    SQS             reduce using rule 26 (logical -> comparison .)
    ;               reduce using rule 26 (logical -> comparison .)
    }               reduce using rule 26 (logical -> comparison .)
    ,               reduce using rule 26 (logical -> comparison .)
    )               reduce using rule 26 (logical -> comparison .)
    ]               reduce using rule 26 (logical -> comparison .)
    EQU             shift and go to state 53
    BOE             shift and go to state 54
    SOE             shift and go to state 55
    NOE             shift and go to state 56
    BIG             shift and go to state 57
    SMA             shift and go to state 58


state 18

    (25) logical -> ! . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    comparison                     shift and go to state 59
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 19

    (33) comparison -> polynomial .
    (34) polynomial -> polynomial . + factor
    (35) polynomial -> polynomial . - factor

    EQU             reduce using rule 33 (comparison -> polynomial .)
    BOE             reduce using rule 33 (comparison -> polynomial .)
    SOE             reduce using rule 33 (comparison -> polynomial .)
    NOE             reduce using rule 33 (comparison -> polynomial .)
    BIG             reduce using rule 33 (comparison -> polynomial .)
    SMA             reduce using rule 33 (comparison -> polynomial .)
    &               reduce using rule 33 (comparison -> polynomial .)
    |               reduce using rule 33 (comparison -> polynomial .)
    SET             reduce using rule 33 (comparison -> polynomial .)
    AAS             reduce using rule 33 (comparison -> polynomial .)
    SAS             reduce using rule 33 (comparison -> polynomial .)
    MAS             reduce using rule 33 (comparison -> polynomial .)
    DAS             reduce using rule 33 (comparison -> polynomial .)
    RAS             reduce using rule 33 (comparison -> polynomial .)
    SQS             reduce using rule 33 (comparison -> polynomial .)
    ;               reduce using rule 33 (comparison -> polynomial .)
    }               reduce using rule 33 (comparison -> polynomial .)
    ,               reduce using rule 33 (comparison -> polynomial .)
    )               reduce using rule 33 (comparison -> polynomial .)
    ]               reduce using rule 33 (comparison -> polynomial .)
    +               shift and go to state 60
    -               shift and go to state 61


state 20

    (36) polynomial -> factor .
    (37) factor -> factor . * element
    (38) factor -> factor . / element
    (39) factor -> factor . % element

    +               reduce using rule 36 (polynomial -> factor .)
    -               reduce using rule 36 (polynomial -> factor .)
    EQU             reduce using rule 36 (polynomial -> factor .)
    BOE             reduce using rule 36 (polynomial -> factor .)
    SOE             reduce using rule 36 (polynomial -> factor .)
    NOE             reduce using rule 36 (polynomial -> factor .)
    BIG             reduce using rule 36 (polynomial -> factor .)
    SMA             reduce using rule 36 (polynomial -> factor .)
    &               reduce using rule 36 (polynomial -> factor .)
    |               reduce using rule 36 (polynomial -> factor .)
    SET             reduce using rule 36 (polynomial -> factor .)
    AAS             reduce using rule 36 (polynomial -> factor .)
    SAS             reduce using rule 36 (polynomial -> factor .)
    MAS             reduce using rule 36 (polynomial -> factor .)
    DAS             reduce using rule 36 (polynomial -> factor .)
    RAS             reduce using rule 36 (polynomial -> factor .)
    SQS             reduce using rule 36 (polynomial -> factor .)
    ;               reduce using rule 36 (polynomial -> factor .)
    }               reduce using rule 36 (polynomial -> factor .)
    ,               reduce using rule 36 (polynomial -> factor .)
    )               reduce using rule 36 (polynomial -> factor .)
    ]               reduce using rule 36 (polynomial -> factor .)
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64


state 21

    (44) element -> - . NUMBER

    NUMBER          shift and go to state 65


state 22

    (40) factor -> element . ^ factor
    (41) factor -> element .

    ^               shift and go to state 66
    *               reduce using rule 41 (factor -> element .)
    /               reduce using rule 41 (factor -> element .)
    %               reduce using rule 41 (factor -> element .)
    +               reduce using rule 41 (factor -> element .)
    -               reduce using rule 41 (factor -> element .)
    EQU             reduce using rule 41 (factor -> element .)
    BOE             reduce using rule 41 (factor -> element .)
    SOE             reduce using rule 41 (factor -> element .)
    NOE             reduce using rule 41 (factor -> element .)
    BIG             reduce using rule 41 (factor -> element .)
    SMA             reduce using rule 41 (factor -> element .)
    &               reduce using rule 41 (factor -> element .)
    |               reduce using rule 41 (factor -> element .)
    SET             reduce using rule 41 (factor -> element .)
    AAS             reduce using rule 41 (factor -> element .)
    SAS             reduce using rule 41 (factor -> element .)
    MAS             reduce using rule 41 (factor -> element .)
    DAS             reduce using rule 41 (factor -> element .)
    RAS             reduce using rule 41 (factor -> element .)
    SQS             reduce using rule 41 (factor -> element .)
    ;               reduce using rule 41 (factor -> element .)
    }               reduce using rule 41 (factor -> element .)
    ,               reduce using rule 41 (factor -> element .)
    )               reduce using rule 41 (factor -> element .)
    ]               reduce using rule 41 (factor -> element .)


state 23

    (42) element -> BREAK .

    ^               reduce using rule 42 (element -> BREAK .)
    *               reduce using rule 42 (element -> BREAK .)
    /               reduce using rule 42 (element -> BREAK .)
    %               reduce using rule 42 (element -> BREAK .)
    +               reduce using rule 42 (element -> BREAK .)
    -               reduce using rule 42 (element -> BREAK .)
    EQU             reduce using rule 42 (element -> BREAK .)
    BOE             reduce using rule 42 (element -> BREAK .)
    SOE             reduce using rule 42 (element -> BREAK .)
    NOE             reduce using rule 42 (element -> BREAK .)
    BIG             reduce using rule 42 (element -> BREAK .)
    SMA             reduce using rule 42 (element -> BREAK .)
    &               reduce using rule 42 (element -> BREAK .)
    |               reduce using rule 42 (element -> BREAK .)
    SET             reduce using rule 42 (element -> BREAK .)
    AAS             reduce using rule 42 (element -> BREAK .)
    SAS             reduce using rule 42 (element -> BREAK .)
    MAS             reduce using rule 42 (element -> BREAK .)
    DAS             reduce using rule 42 (element -> BREAK .)
    RAS             reduce using rule 42 (element -> BREAK .)
    SQS             reduce using rule 42 (element -> BREAK .)
    ;               reduce using rule 42 (element -> BREAK .)
    }               reduce using rule 42 (element -> BREAK .)
    ,               reduce using rule 42 (element -> BREAK .)
    )               reduce using rule 42 (element -> BREAK .)
    ]               reduce using rule 42 (element -> BREAK .)


state 24

    (43) element -> CONTINUE .

    ^               reduce using rule 43 (element -> CONTINUE .)
    *               reduce using rule 43 (element -> CONTINUE .)
    /               reduce using rule 43 (element -> CONTINUE .)
    %               reduce using rule 43 (element -> CONTINUE .)
    +               reduce using rule 43 (element -> CONTINUE .)
    -               reduce using rule 43 (element -> CONTINUE .)
    EQU             reduce using rule 43 (element -> CONTINUE .)
    BOE             reduce using rule 43 (element -> CONTINUE .)
    SOE             reduce using rule 43 (element -> CONTINUE .)
    NOE             reduce using rule 43 (element -> CONTINUE .)
    BIG             reduce using rule 43 (element -> CONTINUE .)
    SMA             reduce using rule 43 (element -> CONTINUE .)
    &               reduce using rule 43 (element -> CONTINUE .)
    |               reduce using rule 43 (element -> CONTINUE .)
    SET             reduce using rule 43 (element -> CONTINUE .)
    AAS             reduce using rule 43 (element -> CONTINUE .)
    SAS             reduce using rule 43 (element -> CONTINUE .)
    MAS             reduce using rule 43 (element -> CONTINUE .)
    DAS             reduce using rule 43 (element -> CONTINUE .)
    RAS             reduce using rule 43 (element -> CONTINUE .)
    SQS             reduce using rule 43 (element -> CONTINUE .)
    ;               reduce using rule 43 (element -> CONTINUE .)
    }               reduce using rule 43 (element -> CONTINUE .)
    ,               reduce using rule 43 (element -> CONTINUE .)
    )               reduce using rule 43 (element -> CONTINUE .)
    ]               reduce using rule 43 (element -> CONTINUE .)


state 25

    (45) element -> NUMBER .

    ^               reduce using rule 45 (element -> NUMBER .)
    *               reduce using rule 45 (element -> NUMBER .)
    /               reduce using rule 45 (element -> NUMBER .)
    %               reduce using rule 45 (element -> NUMBER .)
    +               reduce using rule 45 (element -> NUMBER .)
    -               reduce using rule 45 (element -> NUMBER .)
    EQU             reduce using rule 45 (element -> NUMBER .)
    BOE             reduce using rule 45 (element -> NUMBER .)
    SOE             reduce using rule 45 (element -> NUMBER .)
    NOE             reduce using rule 45 (element -> NUMBER .)
    BIG             reduce using rule 45 (element -> NUMBER .)
    SMA             reduce using rule 45 (element -> NUMBER .)
    &               reduce using rule 45 (element -> NUMBER .)
    |               reduce using rule 45 (element -> NUMBER .)
    SET             reduce using rule 45 (element -> NUMBER .)
    AAS             reduce using rule 45 (element -> NUMBER .)
    SAS             reduce using rule 45 (element -> NUMBER .)
    MAS             reduce using rule 45 (element -> NUMBER .)
    DAS             reduce using rule 45 (element -> NUMBER .)
    RAS             reduce using rule 45 (element -> NUMBER .)
    SQS             reduce using rule 45 (element -> NUMBER .)
    ;               reduce using rule 45 (element -> NUMBER .)
    }               reduce using rule 45 (element -> NUMBER .)
    ,               reduce using rule 45 (element -> NUMBER .)
    )               reduce using rule 45 (element -> NUMBER .)
    ]               reduce using rule 45 (element -> NUMBER .)


state 26

    (46) element -> TRUE .

    ^               reduce using rule 46 (element -> TRUE .)
    *               reduce using rule 46 (element -> TRUE .)
    /               reduce using rule 46 (element -> TRUE .)
    %               reduce using rule 46 (element -> TRUE .)
    +               reduce using rule 46 (element -> TRUE .)
    -               reduce using rule 46 (element -> TRUE .)
    EQU             reduce using rule 46 (element -> TRUE .)
    BOE             reduce using rule 46 (element -> TRUE .)
    SOE             reduce using rule 46 (element -> TRUE .)
    NOE             reduce using rule 46 (element -> TRUE .)
    BIG             reduce using rule 46 (element -> TRUE .)
    SMA             reduce using rule 46 (element -> TRUE .)
    &               reduce using rule 46 (element -> TRUE .)
    |               reduce using rule 46 (element -> TRUE .)
    SET             reduce using rule 46 (element -> TRUE .)
    AAS             reduce using rule 46 (element -> TRUE .)
    SAS             reduce using rule 46 (element -> TRUE .)
    MAS             reduce using rule 46 (element -> TRUE .)
    DAS             reduce using rule 46 (element -> TRUE .)
    RAS             reduce using rule 46 (element -> TRUE .)
    SQS             reduce using rule 46 (element -> TRUE .)
    ;               reduce using rule 46 (element -> TRUE .)
    }               reduce using rule 46 (element -> TRUE .)
    ,               reduce using rule 46 (element -> TRUE .)
    )               reduce using rule 46 (element -> TRUE .)
    ]               reduce using rule 46 (element -> TRUE .)


state 27

    (47) element -> FALSE .

    ^               reduce using rule 47 (element -> FALSE .)
    *               reduce using rule 47 (element -> FALSE .)
    /               reduce using rule 47 (element -> FALSE .)
    %               reduce using rule 47 (element -> FALSE .)
    +               reduce using rule 47 (element -> FALSE .)
    -               reduce using rule 47 (element -> FALSE .)
    EQU             reduce using rule 47 (element -> FALSE .)
    BOE             reduce using rule 47 (element -> FALSE .)
    SOE             reduce using rule 47 (element -> FALSE .)
    NOE             reduce using rule 47 (element -> FALSE .)
    BIG             reduce using rule 47 (element -> FALSE .)
    SMA             reduce using rule 47 (element -> FALSE .)
    &               reduce using rule 47 (element -> FALSE .)
    |               reduce using rule 47 (element -> FALSE .)
    SET             reduce using rule 47 (element -> FALSE .)
    AAS             reduce using rule 47 (element -> FALSE .)
    SAS             reduce using rule 47 (element -> FALSE .)
    MAS             reduce using rule 47 (element -> FALSE .)
    DAS             reduce using rule 47 (element -> FALSE .)
    RAS             reduce using rule 47 (element -> FALSE .)
    SQS             reduce using rule 47 (element -> FALSE .)
    ;               reduce using rule 47 (element -> FALSE .)
    }               reduce using rule 47 (element -> FALSE .)
    ,               reduce using rule 47 (element -> FALSE .)
    )               reduce using rule 47 (element -> FALSE .)
    ]               reduce using rule 47 (element -> FALSE .)


state 28

    (48) element -> STRING .

    ^               reduce using rule 48 (element -> STRING .)
    *               reduce using rule 48 (element -> STRING .)
    /               reduce using rule 48 (element -> STRING .)
    %               reduce using rule 48 (element -> STRING .)
    +               reduce using rule 48 (element -> STRING .)
    -               reduce using rule 48 (element -> STRING .)
    EQU             reduce using rule 48 (element -> STRING .)
    BOE             reduce using rule 48 (element -> STRING .)
    SOE             reduce using rule 48 (element -> STRING .)
    NOE             reduce using rule 48 (element -> STRING .)
    BIG             reduce using rule 48 (element -> STRING .)
    SMA             reduce using rule 48 (element -> STRING .)
    &               reduce using rule 48 (element -> STRING .)
    |               reduce using rule 48 (element -> STRING .)
    SET             reduce using rule 48 (element -> STRING .)
    AAS             reduce using rule 48 (element -> STRING .)
    SAS             reduce using rule 48 (element -> STRING .)
    MAS             reduce using rule 48 (element -> STRING .)
    DAS             reduce using rule 48 (element -> STRING .)
    RAS             reduce using rule 48 (element -> STRING .)
    SQS             reduce using rule 48 (element -> STRING .)
    ;               reduce using rule 48 (element -> STRING .)
    }               reduce using rule 48 (element -> STRING .)
    ,               reduce using rule 48 (element -> STRING .)
    )               reduce using rule 48 (element -> STRING .)
    ]               reduce using rule 48 (element -> STRING .)


state 29

    (1) proc -> proc com .

    {               reduce using rule 1 (proc -> proc com .)
    WHILE           reduce using rule 1 (proc -> proc com .)
    UNTIL           reduce using rule 1 (proc -> proc com .)
    FOR             reduce using rule 1 (proc -> proc com .)
    DEFINE          reduce using rule 1 (proc -> proc com .)
    ;               reduce using rule 1 (proc -> proc com .)
    IF              reduce using rule 1 (proc -> proc com .)
    !               reduce using rule 1 (proc -> proc com .)
    BREAK           reduce using rule 1 (proc -> proc com .)
    CONTINUE        reduce using rule 1 (proc -> proc com .)
    -               reduce using rule 1 (proc -> proc com .)
    NUMBER          reduce using rule 1 (proc -> proc com .)
    TRUE            reduce using rule 1 (proc -> proc com .)
    FALSE           reduce using rule 1 (proc -> proc com .)
    STRING          reduce using rule 1 (proc -> proc com .)
    ID              reduce using rule 1 (proc -> proc com .)
    (               reduce using rule 1 (proc -> proc com .)
    $end            reduce using rule 1 (proc -> proc com .)
    }               reduce using rule 1 (proc -> proc com .)


state 30

    (3) com -> { proc . }
    (1) proc -> proc . com
    (3) com -> . { proc }
    (4) com -> . if
    (7) com -> . WHILE ( expr ) com
    (8) com -> . UNTIL ( expr ) com
    (9) com -> . FOR ( cexpr cexpr expr ) com
    (10) com -> . DEFINE ID ( call ) com
    (11) com -> . cexpr
    (12) com -> . ;
    (5) if -> . IF ( expr ) com ELSE com
    (6) if -> . IF ( expr ) com
    (13) cexpr -> . expr ;
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    }               shift and go to state 67
    {               shift and go to state 3
    WHILE           shift and go to state 5
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    DEFINE          shift and go to state 11
    ;               shift and go to state 13
    IF              shift and go to state 14
    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    (               shift and go to state 6

    com                            shift and go to state 29
    if                             shift and go to state 4
    expr                           shift and go to state 7
    cexpr                          shift and go to state 10
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 31

    (51) element -> { call . }
    (56) call -> call . , expr

    }               shift and go to state 68
    ,               shift and go to state 69


state 32

    (57) call -> expr .
    (13) cexpr -> expr . ;

    }               reduce using rule 57 (call -> expr .)
    ,               reduce using rule 57 (call -> expr .)
    ;               shift and go to state 36


state 33

    (7) com -> WHILE ( . expr ) com
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    expr                           shift and go to state 70
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 34

    (55) element -> ( expr . )

    )               shift and go to state 71


state 35

    (51) element -> { . call }
    (56) call -> . call , expr
    (57) call -> . expr
    (58) call -> .
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    }               reduce using rule 58 (call -> .)
    ,               reduce using rule 58 (call -> .)
    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    call                           shift and go to state 31
    expr                           shift and go to state 72
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 36

    (13) cexpr -> expr ; .

    {               reduce using rule 13 (cexpr -> expr ; .)
    WHILE           reduce using rule 13 (cexpr -> expr ; .)
    UNTIL           reduce using rule 13 (cexpr -> expr ; .)
    FOR             reduce using rule 13 (cexpr -> expr ; .)
    DEFINE          reduce using rule 13 (cexpr -> expr ; .)
    ;               reduce using rule 13 (cexpr -> expr ; .)
    IF              reduce using rule 13 (cexpr -> expr ; .)
    !               reduce using rule 13 (cexpr -> expr ; .)
    BREAK           reduce using rule 13 (cexpr -> expr ; .)
    CONTINUE        reduce using rule 13 (cexpr -> expr ; .)
    -               reduce using rule 13 (cexpr -> expr ; .)
    NUMBER          reduce using rule 13 (cexpr -> expr ; .)
    TRUE            reduce using rule 13 (cexpr -> expr ; .)
    FALSE           reduce using rule 13 (cexpr -> expr ; .)
    STRING          reduce using rule 13 (cexpr -> expr ; .)
    ID              reduce using rule 13 (cexpr -> expr ; .)
    (               reduce using rule 13 (cexpr -> expr ; .)
    $end            reduce using rule 13 (cexpr -> expr ; .)
    }               reduce using rule 13 (cexpr -> expr ; .)
    ELSE            reduce using rule 13 (cexpr -> expr ; .)


state 37

    (8) com -> UNTIL ( . expr ) com
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    expr                           shift and go to state 73
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 38

    (9) com -> FOR ( . cexpr cexpr expr ) com
    (13) cexpr -> . expr ;
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    cexpr                          shift and go to state 74
    expr                           shift and go to state 7
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 39

    (10) com -> DEFINE ID . ( call ) com

    (               shift and go to state 75


state 40

    (49) element -> ID ( . call )
    (56) call -> . call , expr
    (57) call -> . expr
    (58) call -> .
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    )               reduce using rule 58 (call -> .)
    ,               reduce using rule 58 (call -> .)
    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    call                           shift and go to state 76
    expr                           shift and go to state 72
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 41

    (52) element -> ID index .
    (53) index -> index . [ expr ]

    ^               reduce using rule 52 (element -> ID index .)
    *               reduce using rule 52 (element -> ID index .)
    /               reduce using rule 52 (element -> ID index .)
    %               reduce using rule 52 (element -> ID index .)
    +               reduce using rule 52 (element -> ID index .)
    -               reduce using rule 52 (element -> ID index .)
    EQU             reduce using rule 52 (element -> ID index .)
    BOE             reduce using rule 52 (element -> ID index .)
    SOE             reduce using rule 52 (element -> ID index .)
    NOE             reduce using rule 52 (element -> ID index .)
    BIG             reduce using rule 52 (element -> ID index .)
    SMA             reduce using rule 52 (element -> ID index .)
    &               reduce using rule 52 (element -> ID index .)
    |               reduce using rule 52 (element -> ID index .)
    SET             reduce using rule 52 (element -> ID index .)
    AAS             reduce using rule 52 (element -> ID index .)
    SAS             reduce using rule 52 (element -> ID index .)
    MAS             reduce using rule 52 (element -> ID index .)
    DAS             reduce using rule 52 (element -> ID index .)
    RAS             reduce using rule 52 (element -> ID index .)
    SQS             reduce using rule 52 (element -> ID index .)
    ;               reduce using rule 52 (element -> ID index .)
    }               reduce using rule 52 (element -> ID index .)
    ,               reduce using rule 52 (element -> ID index .)
    )               reduce using rule 52 (element -> ID index .)
    ]               reduce using rule 52 (element -> ID index .)
    [               shift and go to state 77


state 42

    (54) index -> [ . expr ]
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    expr                           shift and go to state 78
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 43

    (5) if -> IF ( . expr ) com ELSE com
    (6) if -> IF ( . expr ) com
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    expr                           shift and go to state 79
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 44

    (15) substitute -> substitute SET . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    logical                        shift and go to state 80
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 45

    (16) substitute -> substitute AAS . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    logical                        shift and go to state 81
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 46

    (17) substitute -> substitute SAS . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    logical                        shift and go to state 82
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 47

    (18) substitute -> substitute MAS . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    logical                        shift and go to state 83
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 48

    (19) substitute -> substitute DAS . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    logical                        shift and go to state 84
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 49

    (20) substitute -> substitute RAS . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    logical                        shift and go to state 85
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 50

    (21) substitute -> substitute SQS . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    logical                        shift and go to state 86
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 51

    (23) logical -> logical & . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    comparison                     shift and go to state 87
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 52

    (24) logical -> logical | . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    comparison                     shift and go to state 88
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 53

    (27) comparison -> comparison EQU . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    polynomial                     shift and go to state 89
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 54

    (28) comparison -> comparison BOE . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    polynomial                     shift and go to state 90
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 55

    (29) comparison -> comparison SOE . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    polynomial                     shift and go to state 91
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 56

    (30) comparison -> comparison NOE . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    polynomial                     shift and go to state 92
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 57

    (31) comparison -> comparison BIG . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    polynomial                     shift and go to state 93
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 58

    (32) comparison -> comparison SMA . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    polynomial                     shift and go to state 94
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 59

    (25) logical -> ! comparison .
    (27) comparison -> comparison . EQU polynomial
    (28) comparison -> comparison . BOE polynomial
    (29) comparison -> comparison . SOE polynomial
    (30) comparison -> comparison . NOE polynomial
    (31) comparison -> comparison . BIG polynomial
    (32) comparison -> comparison . SMA polynomial

    &               reduce using rule 25 (logical -> ! comparison .)
    |               reduce using rule 25 (logical -> ! comparison .)
    SET             reduce using rule 25 (logical -> ! comparison .)
    AAS             reduce using rule 25 (logical -> ! comparison .)
    SAS             reduce using rule 25 (logical -> ! comparison .)
    MAS             reduce using rule 25 (logical -> ! comparison .)
    DAS             reduce using rule 25 (logical -> ! comparison .)
    RAS             reduce using rule 25 (logical -> ! comparison .)
    SQS             reduce using rule 25 (logical -> ! comparison .)
    ;               reduce using rule 25 (logical -> ! comparison .)
    }               reduce using rule 25 (logical -> ! comparison .)
    ,               reduce using rule 25 (logical -> ! comparison .)
    )               reduce using rule 25 (logical -> ! comparison .)
    ]               reduce using rule 25 (logical -> ! comparison .)
    EQU             shift and go to state 53
    BOE             shift and go to state 54
    SOE             shift and go to state 55
    NOE             shift and go to state 56
    BIG             shift and go to state 57
    SMA             shift and go to state 58


state 60

    (34) polynomial -> polynomial + . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    factor                         shift and go to state 95
    element                        shift and go to state 22

state 61

    (35) polynomial -> polynomial - . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    factor                         shift and go to state 96
    element                        shift and go to state 22

state 62

    (37) factor -> factor * . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    element                        shift and go to state 97

state 63

    (38) factor -> factor / . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    element                        shift and go to state 98

state 64

    (39) factor -> factor % . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    element                        shift and go to state 99

state 65

    (44) element -> - NUMBER .

    ^               reduce using rule 44 (element -> - NUMBER .)
    *               reduce using rule 44 (element -> - NUMBER .)
    /               reduce using rule 44 (element -> - NUMBER .)
    %               reduce using rule 44 (element -> - NUMBER .)
    +               reduce using rule 44 (element -> - NUMBER .)
    -               reduce using rule 44 (element -> - NUMBER .)
    EQU             reduce using rule 44 (element -> - NUMBER .)
    BOE             reduce using rule 44 (element -> - NUMBER .)
    SOE             reduce using rule 44 (element -> - NUMBER .)
    NOE             reduce using rule 44 (element -> - NUMBER .)
    BIG             reduce using rule 44 (element -> - NUMBER .)
    SMA             reduce using rule 44 (element -> - NUMBER .)
    &               reduce using rule 44 (element -> - NUMBER .)
    |               reduce using rule 44 (element -> - NUMBER .)
    SET             reduce using rule 44 (element -> - NUMBER .)
    AAS             reduce using rule 44 (element -> - NUMBER .)
    SAS             reduce using rule 44 (element -> - NUMBER .)
    MAS             reduce using rule 44 (element -> - NUMBER .)
    DAS             reduce using rule 44 (element -> - NUMBER .)
    RAS             reduce using rule 44 (element -> - NUMBER .)
    SQS             reduce using rule 44 (element -> - NUMBER .)
    ;               reduce using rule 44 (element -> - NUMBER .)
    }               reduce using rule 44 (element -> - NUMBER .)
    ,               reduce using rule 44 (element -> - NUMBER .)
    )               reduce using rule 44 (element -> - NUMBER .)
    ]               reduce using rule 44 (element -> - NUMBER .)


state 66

    (40) factor -> element ^ . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    element                        shift and go to state 22
    factor                         shift and go to state 100

state 67

    (3) com -> { proc } .

    {               reduce using rule 3 (com -> { proc } .)
    WHILE           reduce using rule 3 (com -> { proc } .)
    UNTIL           reduce using rule 3 (com -> { proc } .)
    FOR             reduce using rule 3 (com -> { proc } .)
    DEFINE          reduce using rule 3 (com -> { proc } .)
    ;               reduce using rule 3 (com -> { proc } .)
    IF              reduce using rule 3 (com -> { proc } .)
    !               reduce using rule 3 (com -> { proc } .)
    BREAK           reduce using rule 3 (com -> { proc } .)
    CONTINUE        reduce using rule 3 (com -> { proc } .)
    -               reduce using rule 3 (com -> { proc } .)
    NUMBER          reduce using rule 3 (com -> { proc } .)
    TRUE            reduce using rule 3 (com -> { proc } .)
    FALSE           reduce using rule 3 (com -> { proc } .)
    STRING          reduce using rule 3 (com -> { proc } .)
    ID              reduce using rule 3 (com -> { proc } .)
    (               reduce using rule 3 (com -> { proc } .)
    $end            reduce using rule 3 (com -> { proc } .)
    }               reduce using rule 3 (com -> { proc } .)
    ELSE            reduce using rule 3 (com -> { proc } .)


state 68

    (51) element -> { call } .

    ^               reduce using rule 51 (element -> { call } .)
    *               reduce using rule 51 (element -> { call } .)
    /               reduce using rule 51 (element -> { call } .)
    %               reduce using rule 51 (element -> { call } .)
    +               reduce using rule 51 (element -> { call } .)
    -               reduce using rule 51 (element -> { call } .)
    EQU             reduce using rule 51 (element -> { call } .)
    BOE             reduce using rule 51 (element -> { call } .)
    SOE             reduce using rule 51 (element -> { call } .)
    NOE             reduce using rule 51 (element -> { call } .)
    BIG             reduce using rule 51 (element -> { call } .)
    SMA             reduce using rule 51 (element -> { call } .)
    &               reduce using rule 51 (element -> { call } .)
    |               reduce using rule 51 (element -> { call } .)
    SET             reduce using rule 51 (element -> { call } .)
    AAS             reduce using rule 51 (element -> { call } .)
    SAS             reduce using rule 51 (element -> { call } .)
    MAS             reduce using rule 51 (element -> { call } .)
    DAS             reduce using rule 51 (element -> { call } .)
    RAS             reduce using rule 51 (element -> { call } .)
    SQS             reduce using rule 51 (element -> { call } .)
    ;               reduce using rule 51 (element -> { call } .)
    }               reduce using rule 51 (element -> { call } .)
    ,               reduce using rule 51 (element -> { call } .)
    )               reduce using rule 51 (element -> { call } .)
    ]               reduce using rule 51 (element -> { call } .)


state 69

    (56) call -> call , . expr
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    expr                           shift and go to state 101
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 70

    (7) com -> WHILE ( expr . ) com

    )               shift and go to state 102


state 71

    (55) element -> ( expr ) .

    ^               reduce using rule 55 (element -> ( expr ) .)
    *               reduce using rule 55 (element -> ( expr ) .)
    /               reduce using rule 55 (element -> ( expr ) .)
    %               reduce using rule 55 (element -> ( expr ) .)
    +               reduce using rule 55 (element -> ( expr ) .)
    -               reduce using rule 55 (element -> ( expr ) .)
    EQU             reduce using rule 55 (element -> ( expr ) .)
    BOE             reduce using rule 55 (element -> ( expr ) .)
    SOE             reduce using rule 55 (element -> ( expr ) .)
    NOE             reduce using rule 55 (element -> ( expr ) .)
    BIG             reduce using rule 55 (element -> ( expr ) .)
    SMA             reduce using rule 55 (element -> ( expr ) .)
    &               reduce using rule 55 (element -> ( expr ) .)
    |               reduce using rule 55 (element -> ( expr ) .)
    SET             reduce using rule 55 (element -> ( expr ) .)
    AAS             reduce using rule 55 (element -> ( expr ) .)
    SAS             reduce using rule 55 (element -> ( expr ) .)
    MAS             reduce using rule 55 (element -> ( expr ) .)
    DAS             reduce using rule 55 (element -> ( expr ) .)
    RAS             reduce using rule 55 (element -> ( expr ) .)
    SQS             reduce using rule 55 (element -> ( expr ) .)
    ;               reduce using rule 55 (element -> ( expr ) .)
    }               reduce using rule 55 (element -> ( expr ) .)
    ,               reduce using rule 55 (element -> ( expr ) .)
    )               reduce using rule 55 (element -> ( expr ) .)
    ]               reduce using rule 55 (element -> ( expr ) .)


state 72

    (57) call -> expr .

    }               reduce using rule 57 (call -> expr .)
    ,               reduce using rule 57 (call -> expr .)
    )               reduce using rule 57 (call -> expr .)


state 73

    (8) com -> UNTIL ( expr . ) com

    )               shift and go to state 103


state 74

    (9) com -> FOR ( cexpr . cexpr expr ) com
    (13) cexpr -> . expr ;
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    cexpr                          shift and go to state 104
    expr                           shift and go to state 7
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 75

    (10) com -> DEFINE ID ( . call ) com
    (56) call -> . call , expr
    (57) call -> . expr
    (58) call -> .
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    )               reduce using rule 58 (call -> .)
    ,               reduce using rule 58 (call -> .)
    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    call                           shift and go to state 105
    expr                           shift and go to state 72
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 76

    (49) element -> ID ( call . )
    (56) call -> call . , expr

    )               shift and go to state 106
    ,               shift and go to state 69


state 77

    (53) index -> index [ . expr ]
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    expr                           shift and go to state 107
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 78

    (54) index -> [ expr . ]

    ]               shift and go to state 108


state 79

    (5) if -> IF ( expr . ) com ELSE com
    (6) if -> IF ( expr . ) com

    )               shift and go to state 109


state 80

    (15) substitute -> substitute SET logical .
    (23) logical -> logical . & comparison
    (24) logical -> logical . | comparison

    SET             reduce using rule 15 (substitute -> substitute SET logical .)
    AAS             reduce using rule 15 (substitute -> substitute SET logical .)
    SAS             reduce using rule 15 (substitute -> substitute SET logical .)
    MAS             reduce using rule 15 (substitute -> substitute SET logical .)
    DAS             reduce using rule 15 (substitute -> substitute SET logical .)
    RAS             reduce using rule 15 (substitute -> substitute SET logical .)
    SQS             reduce using rule 15 (substitute -> substitute SET logical .)
    ;               reduce using rule 15 (substitute -> substitute SET logical .)
    }               reduce using rule 15 (substitute -> substitute SET logical .)
    ,               reduce using rule 15 (substitute -> substitute SET logical .)
    )               reduce using rule 15 (substitute -> substitute SET logical .)
    ]               reduce using rule 15 (substitute -> substitute SET logical .)
    &               shift and go to state 51
    |               shift and go to state 52


state 81

    (16) substitute -> substitute AAS logical .
    (23) logical -> logical . & comparison
    (24) logical -> logical . | comparison

    SET             reduce using rule 16 (substitute -> substitute AAS logical .)
    AAS             reduce using rule 16 (substitute -> substitute AAS logical .)
    SAS             reduce using rule 16 (substitute -> substitute AAS logical .)
    MAS             reduce using rule 16 (substitute -> substitute AAS logical .)
    DAS             reduce using rule 16 (substitute -> substitute AAS logical .)
    RAS             reduce using rule 16 (substitute -> substitute AAS logical .)
    SQS             reduce using rule 16 (substitute -> substitute AAS logical .)
    ;               reduce using rule 16 (substitute -> substitute AAS logical .)
    }               reduce using rule 16 (substitute -> substitute AAS logical .)
    ,               reduce using rule 16 (substitute -> substitute AAS logical .)
    )               reduce using rule 16 (substitute -> substitute AAS logical .)
    ]               reduce using rule 16 (substitute -> substitute AAS logical .)
    &               shift and go to state 51
    |               shift and go to state 52


state 82

    (17) substitute -> substitute SAS logical .
    (23) logical -> logical . & comparison
    (24) logical -> logical . | comparison

    SET             reduce using rule 17 (substitute -> substitute SAS logical .)
    AAS             reduce using rule 17 (substitute -> substitute SAS logical .)
    SAS             reduce using rule 17 (substitute -> substitute SAS logical .)
    MAS             reduce using rule 17 (substitute -> substitute SAS logical .)
    DAS             reduce using rule 17 (substitute -> substitute SAS logical .)
    RAS             reduce using rule 17 (substitute -> substitute SAS logical .)
    SQS             reduce using rule 17 (substitute -> substitute SAS logical .)
    ;               reduce using rule 17 (substitute -> substitute SAS logical .)
    }               reduce using rule 17 (substitute -> substitute SAS logical .)
    ,               reduce using rule 17 (substitute -> substitute SAS logical .)
    )               reduce using rule 17 (substitute -> substitute SAS logical .)
    ]               reduce using rule 17 (substitute -> substitute SAS logical .)
    &               shift and go to state 51
    |               shift and go to state 52


state 83

    (18) substitute -> substitute MAS logical .
    (23) logical -> logical . & comparison
    (24) logical -> logical . | comparison

    SET             reduce using rule 18 (substitute -> substitute MAS logical .)
    AAS             reduce using rule 18 (substitute -> substitute MAS logical .)
    SAS             reduce using rule 18 (substitute -> substitute MAS logical .)
    MAS             reduce using rule 18 (substitute -> substitute MAS logical .)
    DAS             reduce using rule 18 (substitute -> substitute MAS logical .)
    RAS             reduce using rule 18 (substitute -> substitute MAS logical .)
    SQS             reduce using rule 18 (substitute -> substitute MAS logical .)
    ;               reduce using rule 18 (substitute -> substitute MAS logical .)
    }               reduce using rule 18 (substitute -> substitute MAS logical .)
    ,               reduce using rule 18 (substitute -> substitute MAS logical .)
    )               reduce using rule 18 (substitute -> substitute MAS logical .)
    ]               reduce using rule 18 (substitute -> substitute MAS logical .)
    &               shift and go to state 51
    |               shift and go to state 52


state 84

    (19) substitute -> substitute DAS logical .
    (23) logical -> logical . & comparison
    (24) logical -> logical . | comparison

    SET             reduce using rule 19 (substitute -> substitute DAS logical .)
    AAS             reduce using rule 19 (substitute -> substitute DAS logical .)
    SAS             reduce using rule 19 (substitute -> substitute DAS logical .)
    MAS             reduce using rule 19 (substitute -> substitute DAS logical .)
    DAS             reduce using rule 19 (substitute -> substitute DAS logical .)
    RAS             reduce using rule 19 (substitute -> substitute DAS logical .)
    SQS             reduce using rule 19 (substitute -> substitute DAS logical .)
    ;               reduce using rule 19 (substitute -> substitute DAS logical .)
    }               reduce using rule 19 (substitute -> substitute DAS logical .)
    ,               reduce using rule 19 (substitute -> substitute DAS logical .)
    )               reduce using rule 19 (substitute -> substitute DAS logical .)
    ]               reduce using rule 19 (substitute -> substitute DAS logical .)
    &               shift and go to state 51
    |               shift and go to state 52


state 85

    (20) substitute -> substitute RAS logical .
    (23) logical -> logical . & comparison
    (24) logical -> logical . | comparison

    SET             reduce using rule 20 (substitute -> substitute RAS logical .)
    AAS             reduce using rule 20 (substitute -> substitute RAS logical .)
    SAS             reduce using rule 20 (substitute -> substitute RAS logical .)
    MAS             reduce using rule 20 (substitute -> substitute RAS logical .)
    DAS             reduce using rule 20 (substitute -> substitute RAS logical .)
    RAS             reduce using rule 20 (substitute -> substitute RAS logical .)
    SQS             reduce using rule 20 (substitute -> substitute RAS logical .)
    ;               reduce using rule 20 (substitute -> substitute RAS logical .)
    }               reduce using rule 20 (substitute -> substitute RAS logical .)
    ,               reduce using rule 20 (substitute -> substitute RAS logical .)
    )               reduce using rule 20 (substitute -> substitute RAS logical .)
    ]               reduce using rule 20 (substitute -> substitute RAS logical .)
    &               shift and go to state 51
    |               shift and go to state 52


state 86

    (21) substitute -> substitute SQS logical .
    (23) logical -> logical . & comparison
    (24) logical -> logical . | comparison

    SET             reduce using rule 21 (substitute -> substitute SQS logical .)
    AAS             reduce using rule 21 (substitute -> substitute SQS logical .)
    SAS             reduce using rule 21 (substitute -> substitute SQS logical .)
    MAS             reduce using rule 21 (substitute -> substitute SQS logical .)
    DAS             reduce using rule 21 (substitute -> substitute SQS logical .)
    RAS             reduce using rule 21 (substitute -> substitute SQS logical .)
    SQS             reduce using rule 21 (substitute -> substitute SQS logical .)
    ;               reduce using rule 21 (substitute -> substitute SQS logical .)
    }               reduce using rule 21 (substitute -> substitute SQS logical .)
    ,               reduce using rule 21 (substitute -> substitute SQS logical .)
    )               reduce using rule 21 (substitute -> substitute SQS logical .)
    ]               reduce using rule 21 (substitute -> substitute SQS logical .)
    &               shift and go to state 51
    |               shift and go to state 52


state 87

    (23) logical -> logical & comparison .
    (27) comparison -> comparison . EQU polynomial
    (28) comparison -> comparison . BOE polynomial
    (29) comparison -> comparison . SOE polynomial
    (30) comparison -> comparison . NOE polynomial
    (31) comparison -> comparison . BIG polynomial
    (32) comparison -> comparison . SMA polynomial

    &               reduce using rule 23 (logical -> logical & comparison .)
    |               reduce using rule 23 (logical -> logical & comparison .)
    SET             reduce using rule 23 (logical -> logical & comparison .)
    AAS             reduce using rule 23 (logical -> logical & comparison .)
    SAS             reduce using rule 23 (logical -> logical & comparison .)
    MAS             reduce using rule 23 (logical -> logical & comparison .)
    DAS             reduce using rule 23 (logical -> logical & comparison .)
    RAS             reduce using rule 23 (logical -> logical & comparison .)
    SQS             reduce using rule 23 (logical -> logical & comparison .)
    ;               reduce using rule 23 (logical -> logical & comparison .)
    }               reduce using rule 23 (logical -> logical & comparison .)
    ,               reduce using rule 23 (logical -> logical & comparison .)
    )               reduce using rule 23 (logical -> logical & comparison .)
    ]               reduce using rule 23 (logical -> logical & comparison .)
    EQU             shift and go to state 53
    BOE             shift and go to state 54
    SOE             shift and go to state 55
    NOE             shift and go to state 56
    BIG             shift and go to state 57
    SMA             shift and go to state 58


state 88

    (24) logical -> logical | comparison .
    (27) comparison -> comparison . EQU polynomial
    (28) comparison -> comparison . BOE polynomial
    (29) comparison -> comparison . SOE polynomial
    (30) comparison -> comparison . NOE polynomial
    (31) comparison -> comparison . BIG polynomial
    (32) comparison -> comparison . SMA polynomial

    &               reduce using rule 24 (logical -> logical | comparison .)
    |               reduce using rule 24 (logical -> logical | comparison .)
    SET             reduce using rule 24 (logical -> logical | comparison .)
    AAS             reduce using rule 24 (logical -> logical | comparison .)
    SAS             reduce using rule 24 (logical -> logical | comparison .)
    MAS             reduce using rule 24 (logical -> logical | comparison .)
    DAS             reduce using rule 24 (logical -> logical | comparison .)
    RAS             reduce using rule 24 (logical -> logical | comparison .)
    SQS             reduce using rule 24 (logical -> logical | comparison .)
    ;               reduce using rule 24 (logical -> logical | comparison .)
    }               reduce using rule 24 (logical -> logical | comparison .)
    ,               reduce using rule 24 (logical -> logical | comparison .)
    )               reduce using rule 24 (logical -> logical | comparison .)
    ]               reduce using rule 24 (logical -> logical | comparison .)
    EQU             shift and go to state 53
    BOE             shift and go to state 54
    SOE             shift and go to state 55
    NOE             shift and go to state 56
    BIG             shift and go to state 57
    SMA             shift and go to state 58


state 89

    (27) comparison -> comparison EQU polynomial .
    (34) polynomial -> polynomial . + factor
    (35) polynomial -> polynomial . - factor

    EQU             reduce using rule 27 (comparison -> comparison EQU polynomial .)
    BOE             reduce using rule 27 (comparison -> comparison EQU polynomial .)
    SOE             reduce using rule 27 (comparison -> comparison EQU polynomial .)
    NOE             reduce using rule 27 (comparison -> comparison EQU polynomial .)
    BIG             reduce using rule 27 (comparison -> comparison EQU polynomial .)
    SMA             reduce using rule 27 (comparison -> comparison EQU polynomial .)
    &               reduce using rule 27 (comparison -> comparison EQU polynomial .)
    |               reduce using rule 27 (comparison -> comparison EQU polynomial .)
    SET             reduce using rule 27 (comparison -> comparison EQU polynomial .)
    AAS             reduce using rule 27 (comparison -> comparison EQU polynomial .)
    SAS             reduce using rule 27 (comparison -> comparison EQU polynomial .)
    MAS             reduce using rule 27 (comparison -> comparison EQU polynomial .)
    DAS             reduce using rule 27 (comparison -> comparison EQU polynomial .)
    RAS             reduce using rule 27 (comparison -> comparison EQU polynomial .)
    SQS             reduce using rule 27 (comparison -> comparison EQU polynomial .)
    ;               reduce using rule 27 (comparison -> comparison EQU polynomial .)
    }               reduce using rule 27 (comparison -> comparison EQU polynomial .)
    ,               reduce using rule 27 (comparison -> comparison EQU polynomial .)
    )               reduce using rule 27 (comparison -> comparison EQU polynomial .)
    ]               reduce using rule 27 (comparison -> comparison EQU polynomial .)
    +               shift and go to state 60
    -               shift and go to state 61


state 90

    (28) comparison -> comparison BOE polynomial .
    (34) polynomial -> polynomial . + factor
    (35) polynomial -> polynomial . - factor

    EQU             reduce using rule 28 (comparison -> comparison BOE polynomial .)
    BOE             reduce using rule 28 (comparison -> comparison BOE polynomial .)
    SOE             reduce using rule 28 (comparison -> comparison BOE polynomial .)
    NOE             reduce using rule 28 (comparison -> comparison BOE polynomial .)
    BIG             reduce using rule 28 (comparison -> comparison BOE polynomial .)
    SMA             reduce using rule 28 (comparison -> comparison BOE polynomial .)
    &               reduce using rule 28 (comparison -> comparison BOE polynomial .)
    |               reduce using rule 28 (comparison -> comparison BOE polynomial .)
    SET             reduce using rule 28 (comparison -> comparison BOE polynomial .)
    AAS             reduce using rule 28 (comparison -> comparison BOE polynomial .)
    SAS             reduce using rule 28 (comparison -> comparison BOE polynomial .)
    MAS             reduce using rule 28 (comparison -> comparison BOE polynomial .)
    DAS             reduce using rule 28 (comparison -> comparison BOE polynomial .)
    RAS             reduce using rule 28 (comparison -> comparison BOE polynomial .)
    SQS             reduce using rule 28 (comparison -> comparison BOE polynomial .)
    ;               reduce using rule 28 (comparison -> comparison BOE polynomial .)
    }               reduce using rule 28 (comparison -> comparison BOE polynomial .)
    ,               reduce using rule 28 (comparison -> comparison BOE polynomial .)
    )               reduce using rule 28 (comparison -> comparison BOE polynomial .)
    ]               reduce using rule 28 (comparison -> comparison BOE polynomial .)
    +               shift and go to state 60
    -               shift and go to state 61


state 91

    (29) comparison -> comparison SOE polynomial .
    (34) polynomial -> polynomial . + factor
    (35) polynomial -> polynomial . - factor

    EQU             reduce using rule 29 (comparison -> comparison SOE polynomial .)
    BOE             reduce using rule 29 (comparison -> comparison SOE polynomial .)
    SOE             reduce using rule 29 (comparison -> comparison SOE polynomial .)
    NOE             reduce using rule 29 (comparison -> comparison SOE polynomial .)
    BIG             reduce using rule 29 (comparison -> comparison SOE polynomial .)
    SMA             reduce using rule 29 (comparison -> comparison SOE polynomial .)
    &               reduce using rule 29 (comparison -> comparison SOE polynomial .)
    |               reduce using rule 29 (comparison -> comparison SOE polynomial .)
    SET             reduce using rule 29 (comparison -> comparison SOE polynomial .)
    AAS             reduce using rule 29 (comparison -> comparison SOE polynomial .)
    SAS             reduce using rule 29 (comparison -> comparison SOE polynomial .)
    MAS             reduce using rule 29 (comparison -> comparison SOE polynomial .)
    DAS             reduce using rule 29 (comparison -> comparison SOE polynomial .)
    RAS             reduce using rule 29 (comparison -> comparison SOE polynomial .)
    SQS             reduce using rule 29 (comparison -> comparison SOE polynomial .)
    ;               reduce using rule 29 (comparison -> comparison SOE polynomial .)
    }               reduce using rule 29 (comparison -> comparison SOE polynomial .)
    ,               reduce using rule 29 (comparison -> comparison SOE polynomial .)
    )               reduce using rule 29 (comparison -> comparison SOE polynomial .)
    ]               reduce using rule 29 (comparison -> comparison SOE polynomial .)
    +               shift and go to state 60
    -               shift and go to state 61


state 92

    (30) comparison -> comparison NOE polynomial .
    (34) polynomial -> polynomial . + factor
    (35) polynomial -> polynomial . - factor

    EQU             reduce using rule 30 (comparison -> comparison NOE polynomial .)
    BOE             reduce using rule 30 (comparison -> comparison NOE polynomial .)
    SOE             reduce using rule 30 (comparison -> comparison NOE polynomial .)
    NOE             reduce using rule 30 (comparison -> comparison NOE polynomial .)
    BIG             reduce using rule 30 (comparison -> comparison NOE polynomial .)
    SMA             reduce using rule 30 (comparison -> comparison NOE polynomial .)
    &               reduce using rule 30 (comparison -> comparison NOE polynomial .)
    |               reduce using rule 30 (comparison -> comparison NOE polynomial .)
    SET             reduce using rule 30 (comparison -> comparison NOE polynomial .)
    AAS             reduce using rule 30 (comparison -> comparison NOE polynomial .)
    SAS             reduce using rule 30 (comparison -> comparison NOE polynomial .)
    MAS             reduce using rule 30 (comparison -> comparison NOE polynomial .)
    DAS             reduce using rule 30 (comparison -> comparison NOE polynomial .)
    RAS             reduce using rule 30 (comparison -> comparison NOE polynomial .)
    SQS             reduce using rule 30 (comparison -> comparison NOE polynomial .)
    ;               reduce using rule 30 (comparison -> comparison NOE polynomial .)
    }               reduce using rule 30 (comparison -> comparison NOE polynomial .)
    ,               reduce using rule 30 (comparison -> comparison NOE polynomial .)
    )               reduce using rule 30 (comparison -> comparison NOE polynomial .)
    ]               reduce using rule 30 (comparison -> comparison NOE polynomial .)
    +               shift and go to state 60
    -               shift and go to state 61


state 93

    (31) comparison -> comparison BIG polynomial .
    (34) polynomial -> polynomial . + factor
    (35) polynomial -> polynomial . - factor

    EQU             reduce using rule 31 (comparison -> comparison BIG polynomial .)
    BOE             reduce using rule 31 (comparison -> comparison BIG polynomial .)
    SOE             reduce using rule 31 (comparison -> comparison BIG polynomial .)
    NOE             reduce using rule 31 (comparison -> comparison BIG polynomial .)
    BIG             reduce using rule 31 (comparison -> comparison BIG polynomial .)
    SMA             reduce using rule 31 (comparison -> comparison BIG polynomial .)
    &               reduce using rule 31 (comparison -> comparison BIG polynomial .)
    |               reduce using rule 31 (comparison -> comparison BIG polynomial .)
    SET             reduce using rule 31 (comparison -> comparison BIG polynomial .)
    AAS             reduce using rule 31 (comparison -> comparison BIG polynomial .)
    SAS             reduce using rule 31 (comparison -> comparison BIG polynomial .)
    MAS             reduce using rule 31 (comparison -> comparison BIG polynomial .)
    DAS             reduce using rule 31 (comparison -> comparison BIG polynomial .)
    RAS             reduce using rule 31 (comparison -> comparison BIG polynomial .)
    SQS             reduce using rule 31 (comparison -> comparison BIG polynomial .)
    ;               reduce using rule 31 (comparison -> comparison BIG polynomial .)
    }               reduce using rule 31 (comparison -> comparison BIG polynomial .)
    ,               reduce using rule 31 (comparison -> comparison BIG polynomial .)
    )               reduce using rule 31 (comparison -> comparison BIG polynomial .)
    ]               reduce using rule 31 (comparison -> comparison BIG polynomial .)
    +               shift and go to state 60
    -               shift and go to state 61


state 94

    (32) comparison -> comparison SMA polynomial .
    (34) polynomial -> polynomial . + factor
    (35) polynomial -> polynomial . - factor

    EQU             reduce using rule 32 (comparison -> comparison SMA polynomial .)
    BOE             reduce using rule 32 (comparison -> comparison SMA polynomial .)
    SOE             reduce using rule 32 (comparison -> comparison SMA polynomial .)
    NOE             reduce using rule 32 (comparison -> comparison SMA polynomial .)
    BIG             reduce using rule 32 (comparison -> comparison SMA polynomial .)
    SMA             reduce using rule 32 (comparison -> comparison SMA polynomial .)
    &               reduce using rule 32 (comparison -> comparison SMA polynomial .)
    |               reduce using rule 32 (comparison -> comparison SMA polynomial .)
    SET             reduce using rule 32 (comparison -> comparison SMA polynomial .)
    AAS             reduce using rule 32 (comparison -> comparison SMA polynomial .)
    SAS             reduce using rule 32 (comparison -> comparison SMA polynomial .)
    MAS             reduce using rule 32 (comparison -> comparison SMA polynomial .)
    DAS             reduce using rule 32 (comparison -> comparison SMA polynomial .)
    RAS             reduce using rule 32 (comparison -> comparison SMA polynomial .)
    SQS             reduce using rule 32 (comparison -> comparison SMA polynomial .)
    ;               reduce using rule 32 (comparison -> comparison SMA polynomial .)
    }               reduce using rule 32 (comparison -> comparison SMA polynomial .)
    ,               reduce using rule 32 (comparison -> comparison SMA polynomial .)
    )               reduce using rule 32 (comparison -> comparison SMA polynomial .)
    ]               reduce using rule 32 (comparison -> comparison SMA polynomial .)
    +               shift and go to state 60
    -               shift and go to state 61


state 95

    (34) polynomial -> polynomial + factor .
    (37) factor -> factor . * element
    (38) factor -> factor . / element
    (39) factor -> factor . % element

    +               reduce using rule 34 (polynomial -> polynomial + factor .)
    -               reduce using rule 34 (polynomial -> polynomial + factor .)
    EQU             reduce using rule 34 (polynomial -> polynomial + factor .)
    BOE             reduce using rule 34 (polynomial -> polynomial + factor .)
    SOE             reduce using rule 34 (polynomial -> polynomial + factor .)
    NOE             reduce using rule 34 (polynomial -> polynomial + factor .)
    BIG             reduce using rule 34 (polynomial -> polynomial + factor .)
    SMA             reduce using rule 34 (polynomial -> polynomial + factor .)
    &               reduce using rule 34 (polynomial -> polynomial + factor .)
    |               reduce using rule 34 (polynomial -> polynomial + factor .)
    SET             reduce using rule 34 (polynomial -> polynomial + factor .)
    AAS             reduce using rule 34 (polynomial -> polynomial + factor .)
    SAS             reduce using rule 34 (polynomial -> polynomial + factor .)
    MAS             reduce using rule 34 (polynomial -> polynomial + factor .)
    DAS             reduce using rule 34 (polynomial -> polynomial + factor .)
    RAS             reduce using rule 34 (polynomial -> polynomial + factor .)
    SQS             reduce using rule 34 (polynomial -> polynomial + factor .)
    ;               reduce using rule 34 (polynomial -> polynomial + factor .)
    }               reduce using rule 34 (polynomial -> polynomial + factor .)
    ,               reduce using rule 34 (polynomial -> polynomial + factor .)
    )               reduce using rule 34 (polynomial -> polynomial + factor .)
    ]               reduce using rule 34 (polynomial -> polynomial + factor .)
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64


state 96

    (35) polynomial -> polynomial - factor .
    (37) factor -> factor . * element
    (38) factor -> factor . / element
    (39) factor -> factor . % element

    +               reduce using rule 35 (polynomial -> polynomial - factor .)
    -               reduce using rule 35 (polynomial -> polynomial - factor .)
    EQU             reduce using rule 35 (polynomial -> polynomial - factor .)
    BOE             reduce using rule 35 (polynomial -> polynomial - factor .)
    SOE             reduce using rule 35 (polynomial -> polynomial - factor .)
    NOE             reduce using rule 35 (polynomial -> polynomial - factor .)
    BIG             reduce using rule 35 (polynomial -> polynomial - factor .)
    SMA             reduce using rule 35 (polynomial -> polynomial - factor .)
    &               reduce using rule 35 (polynomial -> polynomial - factor .)
    |               reduce using rule 35 (polynomial -> polynomial - factor .)
    SET             reduce using rule 35 (polynomial -> polynomial - factor .)
    AAS             reduce using rule 35 (polynomial -> polynomial - factor .)
    SAS             reduce using rule 35 (polynomial -> polynomial - factor .)
    MAS             reduce using rule 35 (polynomial -> polynomial - factor .)
    DAS             reduce using rule 35 (polynomial -> polynomial - factor .)
    RAS             reduce using rule 35 (polynomial -> polynomial - factor .)
    SQS             reduce using rule 35 (polynomial -> polynomial - factor .)
    ;               reduce using rule 35 (polynomial -> polynomial - factor .)
    }               reduce using rule 35 (polynomial -> polynomial - factor .)
    ,               reduce using rule 35 (polynomial -> polynomial - factor .)
    )               reduce using rule 35 (polynomial -> polynomial - factor .)
    ]               reduce using rule 35 (polynomial -> polynomial - factor .)
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64


state 97

    (37) factor -> factor * element .

    *               reduce using rule 37 (factor -> factor * element .)
    /               reduce using rule 37 (factor -> factor * element .)
    %               reduce using rule 37 (factor -> factor * element .)
    +               reduce using rule 37 (factor -> factor * element .)
    -               reduce using rule 37 (factor -> factor * element .)
    EQU             reduce using rule 37 (factor -> factor * element .)
    BOE             reduce using rule 37 (factor -> factor * element .)
    SOE             reduce using rule 37 (factor -> factor * element .)
    NOE             reduce using rule 37 (factor -> factor * element .)
    BIG             reduce using rule 37 (factor -> factor * element .)
    SMA             reduce using rule 37 (factor -> factor * element .)
    &               reduce using rule 37 (factor -> factor * element .)
    |               reduce using rule 37 (factor -> factor * element .)
    SET             reduce using rule 37 (factor -> factor * element .)
    AAS             reduce using rule 37 (factor -> factor * element .)
    SAS             reduce using rule 37 (factor -> factor * element .)
    MAS             reduce using rule 37 (factor -> factor * element .)
    DAS             reduce using rule 37 (factor -> factor * element .)
    RAS             reduce using rule 37 (factor -> factor * element .)
    SQS             reduce using rule 37 (factor -> factor * element .)
    ;               reduce using rule 37 (factor -> factor * element .)
    }               reduce using rule 37 (factor -> factor * element .)
    ,               reduce using rule 37 (factor -> factor * element .)
    )               reduce using rule 37 (factor -> factor * element .)
    ]               reduce using rule 37 (factor -> factor * element .)


state 98

    (38) factor -> factor / element .

    *               reduce using rule 38 (factor -> factor / element .)
    /               reduce using rule 38 (factor -> factor / element .)
    %               reduce using rule 38 (factor -> factor / element .)
    +               reduce using rule 38 (factor -> factor / element .)
    -               reduce using rule 38 (factor -> factor / element .)
    EQU             reduce using rule 38 (factor -> factor / element .)
    BOE             reduce using rule 38 (factor -> factor / element .)
    SOE             reduce using rule 38 (factor -> factor / element .)
    NOE             reduce using rule 38 (factor -> factor / element .)
    BIG             reduce using rule 38 (factor -> factor / element .)
    SMA             reduce using rule 38 (factor -> factor / element .)
    &               reduce using rule 38 (factor -> factor / element .)
    |               reduce using rule 38 (factor -> factor / element .)
    SET             reduce using rule 38 (factor -> factor / element .)
    AAS             reduce using rule 38 (factor -> factor / element .)
    SAS             reduce using rule 38 (factor -> factor / element .)
    MAS             reduce using rule 38 (factor -> factor / element .)
    DAS             reduce using rule 38 (factor -> factor / element .)
    RAS             reduce using rule 38 (factor -> factor / element .)
    SQS             reduce using rule 38 (factor -> factor / element .)
    ;               reduce using rule 38 (factor -> factor / element .)
    }               reduce using rule 38 (factor -> factor / element .)
    ,               reduce using rule 38 (factor -> factor / element .)
    )               reduce using rule 38 (factor -> factor / element .)
    ]               reduce using rule 38 (factor -> factor / element .)


state 99

    (39) factor -> factor % element .

    *               reduce using rule 39 (factor -> factor % element .)
    /               reduce using rule 39 (factor -> factor % element .)
    %               reduce using rule 39 (factor -> factor % element .)
    +               reduce using rule 39 (factor -> factor % element .)
    -               reduce using rule 39 (factor -> factor % element .)
    EQU             reduce using rule 39 (factor -> factor % element .)
    BOE             reduce using rule 39 (factor -> factor % element .)
    SOE             reduce using rule 39 (factor -> factor % element .)
    NOE             reduce using rule 39 (factor -> factor % element .)
    BIG             reduce using rule 39 (factor -> factor % element .)
    SMA             reduce using rule 39 (factor -> factor % element .)
    &               reduce using rule 39 (factor -> factor % element .)
    |               reduce using rule 39 (factor -> factor % element .)
    SET             reduce using rule 39 (factor -> factor % element .)
    AAS             reduce using rule 39 (factor -> factor % element .)
    SAS             reduce using rule 39 (factor -> factor % element .)
    MAS             reduce using rule 39 (factor -> factor % element .)
    DAS             reduce using rule 39 (factor -> factor % element .)
    RAS             reduce using rule 39 (factor -> factor % element .)
    SQS             reduce using rule 39 (factor -> factor % element .)
    ;               reduce using rule 39 (factor -> factor % element .)
    }               reduce using rule 39 (factor -> factor % element .)
    ,               reduce using rule 39 (factor -> factor % element .)
    )               reduce using rule 39 (factor -> factor % element .)
    ]               reduce using rule 39 (factor -> factor % element .)


state 100

    (40) factor -> element ^ factor .
    (37) factor -> factor . * element
    (38) factor -> factor . / element
    (39) factor -> factor . % element

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for % resolved as shift
    +               reduce using rule 40 (factor -> element ^ factor .)
    -               reduce using rule 40 (factor -> element ^ factor .)
    EQU             reduce using rule 40 (factor -> element ^ factor .)
    BOE             reduce using rule 40 (factor -> element ^ factor .)
    SOE             reduce using rule 40 (factor -> element ^ factor .)
    NOE             reduce using rule 40 (factor -> element ^ factor .)
    BIG             reduce using rule 40 (factor -> element ^ factor .)
    SMA             reduce using rule 40 (factor -> element ^ factor .)
    &               reduce using rule 40 (factor -> element ^ factor .)
    |               reduce using rule 40 (factor -> element ^ factor .)
    SET             reduce using rule 40 (factor -> element ^ factor .)
    AAS             reduce using rule 40 (factor -> element ^ factor .)
    SAS             reduce using rule 40 (factor -> element ^ factor .)
    MAS             reduce using rule 40 (factor -> element ^ factor .)
    DAS             reduce using rule 40 (factor -> element ^ factor .)
    RAS             reduce using rule 40 (factor -> element ^ factor .)
    SQS             reduce using rule 40 (factor -> element ^ factor .)
    ;               reduce using rule 40 (factor -> element ^ factor .)
    }               reduce using rule 40 (factor -> element ^ factor .)
    ,               reduce using rule 40 (factor -> element ^ factor .)
    )               reduce using rule 40 (factor -> element ^ factor .)
    ]               reduce using rule 40 (factor -> element ^ factor .)
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64

  ! *               [ reduce using rule 40 (factor -> element ^ factor .) ]
  ! /               [ reduce using rule 40 (factor -> element ^ factor .) ]
  ! %               [ reduce using rule 40 (factor -> element ^ factor .) ]


state 101

    (56) call -> call , expr .

    }               reduce using rule 56 (call -> call , expr .)
    ,               reduce using rule 56 (call -> call , expr .)
    )               reduce using rule 56 (call -> call , expr .)


state 102

    (7) com -> WHILE ( expr ) . com
    (3) com -> . { proc }
    (4) com -> . if
    (7) com -> . WHILE ( expr ) com
    (8) com -> . UNTIL ( expr ) com
    (9) com -> . FOR ( cexpr cexpr expr ) com
    (10) com -> . DEFINE ID ( call ) com
    (11) com -> . cexpr
    (12) com -> . ;
    (5) if -> . IF ( expr ) com ELSE com
    (6) if -> . IF ( expr ) com
    (13) cexpr -> . expr ;
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    {               shift and go to state 3
    WHILE           shift and go to state 5
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    DEFINE          shift and go to state 11
    ;               shift and go to state 13
    IF              shift and go to state 14
    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    (               shift and go to state 6

    expr                           shift and go to state 7
    com                            shift and go to state 110
    if                             shift and go to state 4
    cexpr                          shift and go to state 10
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 103

    (8) com -> UNTIL ( expr ) . com
    (3) com -> . { proc }
    (4) com -> . if
    (7) com -> . WHILE ( expr ) com
    (8) com -> . UNTIL ( expr ) com
    (9) com -> . FOR ( cexpr cexpr expr ) com
    (10) com -> . DEFINE ID ( call ) com
    (11) com -> . cexpr
    (12) com -> . ;
    (5) if -> . IF ( expr ) com ELSE com
    (6) if -> . IF ( expr ) com
    (13) cexpr -> . expr ;
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    {               shift and go to state 3
    WHILE           shift and go to state 5
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    DEFINE          shift and go to state 11
    ;               shift and go to state 13
    IF              shift and go to state 14
    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    (               shift and go to state 6

    expr                           shift and go to state 7
    com                            shift and go to state 111
    if                             shift and go to state 4
    cexpr                          shift and go to state 10
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 104

    (9) com -> FOR ( cexpr cexpr . expr ) com
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    {               shift and go to state 35
    (               shift and go to state 6

    expr                           shift and go to state 112
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 105

    (10) com -> DEFINE ID ( call . ) com
    (56) call -> call . , expr

    )               shift and go to state 113
    ,               shift and go to state 69


state 106

    (49) element -> ID ( call ) .

    ^               reduce using rule 49 (element -> ID ( call ) .)
    *               reduce using rule 49 (element -> ID ( call ) .)
    /               reduce using rule 49 (element -> ID ( call ) .)
    %               reduce using rule 49 (element -> ID ( call ) .)
    +               reduce using rule 49 (element -> ID ( call ) .)
    -               reduce using rule 49 (element -> ID ( call ) .)
    EQU             reduce using rule 49 (element -> ID ( call ) .)
    BOE             reduce using rule 49 (element -> ID ( call ) .)
    SOE             reduce using rule 49 (element -> ID ( call ) .)
    NOE             reduce using rule 49 (element -> ID ( call ) .)
    BIG             reduce using rule 49 (element -> ID ( call ) .)
    SMA             reduce using rule 49 (element -> ID ( call ) .)
    &               reduce using rule 49 (element -> ID ( call ) .)
    |               reduce using rule 49 (element -> ID ( call ) .)
    SET             reduce using rule 49 (element -> ID ( call ) .)
    AAS             reduce using rule 49 (element -> ID ( call ) .)
    SAS             reduce using rule 49 (element -> ID ( call ) .)
    MAS             reduce using rule 49 (element -> ID ( call ) .)
    DAS             reduce using rule 49 (element -> ID ( call ) .)
    RAS             reduce using rule 49 (element -> ID ( call ) .)
    SQS             reduce using rule 49 (element -> ID ( call ) .)
    ;               reduce using rule 49 (element -> ID ( call ) .)
    }               reduce using rule 49 (element -> ID ( call ) .)
    ,               reduce using rule 49 (element -> ID ( call ) .)
    )               reduce using rule 49 (element -> ID ( call ) .)
    ]               reduce using rule 49 (element -> ID ( call ) .)


state 107

    (53) index -> index [ expr . ]

    ]               shift and go to state 114


state 108

    (54) index -> [ expr ] .

    [               reduce using rule 54 (index -> [ expr ] .)
    ^               reduce using rule 54 (index -> [ expr ] .)
    *               reduce using rule 54 (index -> [ expr ] .)
    /               reduce using rule 54 (index -> [ expr ] .)
    %               reduce using rule 54 (index -> [ expr ] .)
    +               reduce using rule 54 (index -> [ expr ] .)
    -               reduce using rule 54 (index -> [ expr ] .)
    EQU             reduce using rule 54 (index -> [ expr ] .)
    BOE             reduce using rule 54 (index -> [ expr ] .)
    SOE             reduce using rule 54 (index -> [ expr ] .)
    NOE             reduce using rule 54 (index -> [ expr ] .)
    BIG             reduce using rule 54 (index -> [ expr ] .)
    SMA             reduce using rule 54 (index -> [ expr ] .)
    &               reduce using rule 54 (index -> [ expr ] .)
    |               reduce using rule 54 (index -> [ expr ] .)
    SET             reduce using rule 54 (index -> [ expr ] .)
    AAS             reduce using rule 54 (index -> [ expr ] .)
    SAS             reduce using rule 54 (index -> [ expr ] .)
    MAS             reduce using rule 54 (index -> [ expr ] .)
    DAS             reduce using rule 54 (index -> [ expr ] .)
    RAS             reduce using rule 54 (index -> [ expr ] .)
    SQS             reduce using rule 54 (index -> [ expr ] .)
    ;               reduce using rule 54 (index -> [ expr ] .)
    }               reduce using rule 54 (index -> [ expr ] .)
    ,               reduce using rule 54 (index -> [ expr ] .)
    )               reduce using rule 54 (index -> [ expr ] .)
    ]               reduce using rule 54 (index -> [ expr ] .)


state 109

    (5) if -> IF ( expr ) . com ELSE com
    (6) if -> IF ( expr ) . com
    (3) com -> . { proc }
    (4) com -> . if
    (7) com -> . WHILE ( expr ) com
    (8) com -> . UNTIL ( expr ) com
    (9) com -> . FOR ( cexpr cexpr expr ) com
    (10) com -> . DEFINE ID ( call ) com
    (11) com -> . cexpr
    (12) com -> . ;
    (5) if -> . IF ( expr ) com ELSE com
    (6) if -> . IF ( expr ) com
    (13) cexpr -> . expr ;
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    {               shift and go to state 3
    WHILE           shift and go to state 5
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    DEFINE          shift and go to state 11
    ;               shift and go to state 13
    IF              shift and go to state 14
    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    (               shift and go to state 6

    expr                           shift and go to state 7
    com                            shift and go to state 115
    if                             shift and go to state 4
    cexpr                          shift and go to state 10
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 110

    (7) com -> WHILE ( expr ) com .

    {               reduce using rule 7 (com -> WHILE ( expr ) com .)
    WHILE           reduce using rule 7 (com -> WHILE ( expr ) com .)
    UNTIL           reduce using rule 7 (com -> WHILE ( expr ) com .)
    FOR             reduce using rule 7 (com -> WHILE ( expr ) com .)
    DEFINE          reduce using rule 7 (com -> WHILE ( expr ) com .)
    ;               reduce using rule 7 (com -> WHILE ( expr ) com .)
    IF              reduce using rule 7 (com -> WHILE ( expr ) com .)
    !               reduce using rule 7 (com -> WHILE ( expr ) com .)
    BREAK           reduce using rule 7 (com -> WHILE ( expr ) com .)
    CONTINUE        reduce using rule 7 (com -> WHILE ( expr ) com .)
    -               reduce using rule 7 (com -> WHILE ( expr ) com .)
    NUMBER          reduce using rule 7 (com -> WHILE ( expr ) com .)
    TRUE            reduce using rule 7 (com -> WHILE ( expr ) com .)
    FALSE           reduce using rule 7 (com -> WHILE ( expr ) com .)
    STRING          reduce using rule 7 (com -> WHILE ( expr ) com .)
    ID              reduce using rule 7 (com -> WHILE ( expr ) com .)
    (               reduce using rule 7 (com -> WHILE ( expr ) com .)
    $end            reduce using rule 7 (com -> WHILE ( expr ) com .)
    }               reduce using rule 7 (com -> WHILE ( expr ) com .)
    ELSE            reduce using rule 7 (com -> WHILE ( expr ) com .)


state 111

    (8) com -> UNTIL ( expr ) com .

    {               reduce using rule 8 (com -> UNTIL ( expr ) com .)
    WHILE           reduce using rule 8 (com -> UNTIL ( expr ) com .)
    UNTIL           reduce using rule 8 (com -> UNTIL ( expr ) com .)
    FOR             reduce using rule 8 (com -> UNTIL ( expr ) com .)
    DEFINE          reduce using rule 8 (com -> UNTIL ( expr ) com .)
    ;               reduce using rule 8 (com -> UNTIL ( expr ) com .)
    IF              reduce using rule 8 (com -> UNTIL ( expr ) com .)
    !               reduce using rule 8 (com -> UNTIL ( expr ) com .)
    BREAK           reduce using rule 8 (com -> UNTIL ( expr ) com .)
    CONTINUE        reduce using rule 8 (com -> UNTIL ( expr ) com .)
    -               reduce using rule 8 (com -> UNTIL ( expr ) com .)
    NUMBER          reduce using rule 8 (com -> UNTIL ( expr ) com .)
    TRUE            reduce using rule 8 (com -> UNTIL ( expr ) com .)
    FALSE           reduce using rule 8 (com -> UNTIL ( expr ) com .)
    STRING          reduce using rule 8 (com -> UNTIL ( expr ) com .)
    ID              reduce using rule 8 (com -> UNTIL ( expr ) com .)
    (               reduce using rule 8 (com -> UNTIL ( expr ) com .)
    $end            reduce using rule 8 (com -> UNTIL ( expr ) com .)
    }               reduce using rule 8 (com -> UNTIL ( expr ) com .)
    ELSE            reduce using rule 8 (com -> UNTIL ( expr ) com .)


state 112

    (9) com -> FOR ( cexpr cexpr expr . ) com

    )               shift and go to state 116


state 113

    (10) com -> DEFINE ID ( call ) . com
    (3) com -> . { proc }
    (4) com -> . if
    (7) com -> . WHILE ( expr ) com
    (8) com -> . UNTIL ( expr ) com
    (9) com -> . FOR ( cexpr cexpr expr ) com
    (10) com -> . DEFINE ID ( call ) com
    (11) com -> . cexpr
    (12) com -> . ;
    (5) if -> . IF ( expr ) com ELSE com
    (6) if -> . IF ( expr ) com
    (13) cexpr -> . expr ;
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    {               shift and go to state 3
    WHILE           shift and go to state 5
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    DEFINE          shift and go to state 11
    ;               shift and go to state 13
    IF              shift and go to state 14
    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    (               shift and go to state 6

    com                            shift and go to state 117
    if                             shift and go to state 4
    expr                           shift and go to state 7
    cexpr                          shift and go to state 10
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 114

    (53) index -> index [ expr ] .

    [               reduce using rule 53 (index -> index [ expr ] .)
    ^               reduce using rule 53 (index -> index [ expr ] .)
    *               reduce using rule 53 (index -> index [ expr ] .)
    /               reduce using rule 53 (index -> index [ expr ] .)
    %               reduce using rule 53 (index -> index [ expr ] .)
    +               reduce using rule 53 (index -> index [ expr ] .)
    -               reduce using rule 53 (index -> index [ expr ] .)
    EQU             reduce using rule 53 (index -> index [ expr ] .)
    BOE             reduce using rule 53 (index -> index [ expr ] .)
    SOE             reduce using rule 53 (index -> index [ expr ] .)
    NOE             reduce using rule 53 (index -> index [ expr ] .)
    BIG             reduce using rule 53 (index -> index [ expr ] .)
    SMA             reduce using rule 53 (index -> index [ expr ] .)
    &               reduce using rule 53 (index -> index [ expr ] .)
    |               reduce using rule 53 (index -> index [ expr ] .)
    SET             reduce using rule 53 (index -> index [ expr ] .)
    AAS             reduce using rule 53 (index -> index [ expr ] .)
    SAS             reduce using rule 53 (index -> index [ expr ] .)
    MAS             reduce using rule 53 (index -> index [ expr ] .)
    DAS             reduce using rule 53 (index -> index [ expr ] .)
    RAS             reduce using rule 53 (index -> index [ expr ] .)
    SQS             reduce using rule 53 (index -> index [ expr ] .)
    ;               reduce using rule 53 (index -> index [ expr ] .)
    }               reduce using rule 53 (index -> index [ expr ] .)
    ,               reduce using rule 53 (index -> index [ expr ] .)
    )               reduce using rule 53 (index -> index [ expr ] .)
    ]               reduce using rule 53 (index -> index [ expr ] .)


state 115

    (5) if -> IF ( expr ) com . ELSE com
    (6) if -> IF ( expr ) com .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 118
    {               reduce using rule 6 (if -> IF ( expr ) com .)
    WHILE           reduce using rule 6 (if -> IF ( expr ) com .)
    UNTIL           reduce using rule 6 (if -> IF ( expr ) com .)
    FOR             reduce using rule 6 (if -> IF ( expr ) com .)
    DEFINE          reduce using rule 6 (if -> IF ( expr ) com .)
    ;               reduce using rule 6 (if -> IF ( expr ) com .)
    IF              reduce using rule 6 (if -> IF ( expr ) com .)
    !               reduce using rule 6 (if -> IF ( expr ) com .)
    BREAK           reduce using rule 6 (if -> IF ( expr ) com .)
    CONTINUE        reduce using rule 6 (if -> IF ( expr ) com .)
    -               reduce using rule 6 (if -> IF ( expr ) com .)
    NUMBER          reduce using rule 6 (if -> IF ( expr ) com .)
    TRUE            reduce using rule 6 (if -> IF ( expr ) com .)
    FALSE           reduce using rule 6 (if -> IF ( expr ) com .)
    STRING          reduce using rule 6 (if -> IF ( expr ) com .)
    ID              reduce using rule 6 (if -> IF ( expr ) com .)
    (               reduce using rule 6 (if -> IF ( expr ) com .)
    $end            reduce using rule 6 (if -> IF ( expr ) com .)
    }               reduce using rule 6 (if -> IF ( expr ) com .)

  ! ELSE            [ reduce using rule 6 (if -> IF ( expr ) com .) ]


state 116

    (9) com -> FOR ( cexpr cexpr expr ) . com
    (3) com -> . { proc }
    (4) com -> . if
    (7) com -> . WHILE ( expr ) com
    (8) com -> . UNTIL ( expr ) com
    (9) com -> . FOR ( cexpr cexpr expr ) com
    (10) com -> . DEFINE ID ( call ) com
    (11) com -> . cexpr
    (12) com -> . ;
    (5) if -> . IF ( expr ) com ELSE com
    (6) if -> . IF ( expr ) com
    (13) cexpr -> . expr ;
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    {               shift and go to state 3
    WHILE           shift and go to state 5
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    DEFINE          shift and go to state 11
    ;               shift and go to state 13
    IF              shift and go to state 14
    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    (               shift and go to state 6

    cexpr                          shift and go to state 10
    expr                           shift and go to state 7
    com                            shift and go to state 119
    if                             shift and go to state 4
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 117

    (10) com -> DEFINE ID ( call ) com .

    {               reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    WHILE           reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    UNTIL           reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    FOR             reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    DEFINE          reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    ;               reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    IF              reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    !               reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    BREAK           reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    CONTINUE        reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    -               reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    NUMBER          reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    TRUE            reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    FALSE           reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    STRING          reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    ID              reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    (               reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    $end            reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    }               reduce using rule 10 (com -> DEFINE ID ( call ) com .)
    ELSE            reduce using rule 10 (com -> DEFINE ID ( call ) com .)


state 118

    (5) if -> IF ( expr ) com ELSE . com
    (3) com -> . { proc }
    (4) com -> . if
    (7) com -> . WHILE ( expr ) com
    (8) com -> . UNTIL ( expr ) com
    (9) com -> . FOR ( cexpr cexpr expr ) com
    (10) com -> . DEFINE ID ( call ) com
    (11) com -> . cexpr
    (12) com -> . ;
    (5) if -> . IF ( expr ) com ELSE com
    (6) if -> . IF ( expr ) com
    (13) cexpr -> . expr ;
    (14) expr -> . substitute
    (15) substitute -> . substitute SET logical
    (16) substitute -> . substitute AAS logical
    (17) substitute -> . substitute SAS logical
    (18) substitute -> . substitute MAS logical
    (19) substitute -> . substitute DAS logical
    (20) substitute -> . substitute RAS logical
    (21) substitute -> . substitute SQS logical
    (22) substitute -> . logical
    (23) logical -> . logical & comparison
    (24) logical -> . logical | comparison
    (25) logical -> . ! comparison
    (26) logical -> . comparison
    (27) comparison -> . comparison EQU polynomial
    (28) comparison -> . comparison BOE polynomial
    (29) comparison -> . comparison SOE polynomial
    (30) comparison -> . comparison NOE polynomial
    (31) comparison -> . comparison BIG polynomial
    (32) comparison -> . comparison SMA polynomial
    (33) comparison -> . polynomial
    (34) polynomial -> . polynomial + factor
    (35) polynomial -> . polynomial - factor
    (36) polynomial -> . factor
    (37) factor -> . factor * element
    (38) factor -> . factor / element
    (39) factor -> . factor % element
    (40) factor -> . element ^ factor
    (41) factor -> . element
    (42) element -> . BREAK
    (43) element -> . CONTINUE
    (44) element -> . - NUMBER
    (45) element -> . NUMBER
    (46) element -> . TRUE
    (47) element -> . FALSE
    (48) element -> . STRING
    (49) element -> . ID ( call )
    (50) element -> . ID
    (51) element -> . { call }
    (52) element -> . ID index
    (55) element -> . ( expr )

    {               shift and go to state 3
    WHILE           shift and go to state 5
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    DEFINE          shift and go to state 11
    ;               shift and go to state 13
    IF              shift and go to state 14
    !               shift and go to state 18
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    -               shift and go to state 21
    NUMBER          shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    STRING          shift and go to state 28
    ID              shift and go to state 12
    (               shift and go to state 6

    expr                           shift and go to state 7
    com                            shift and go to state 120
    if                             shift and go to state 4
    cexpr                          shift and go to state 10
    substitute                     shift and go to state 15
    logical                        shift and go to state 16
    comparison                     shift and go to state 17
    polynomial                     shift and go to state 19
    factor                         shift and go to state 20
    element                        shift and go to state 22

state 119

    (9) com -> FOR ( cexpr cexpr expr ) com .

    {               reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    WHILE           reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    UNTIL           reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    FOR             reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    DEFINE          reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    ;               reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    IF              reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    !               reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    BREAK           reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    CONTINUE        reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    -               reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    NUMBER          reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    TRUE            reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    FALSE           reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    STRING          reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    ID              reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    (               reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    $end            reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    }               reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)
    ELSE            reduce using rule 9 (com -> FOR ( cexpr cexpr expr ) com .)


state 120

    (5) if -> IF ( expr ) com ELSE com .

    {               reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    WHILE           reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    UNTIL           reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    FOR             reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    DEFINE          reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    ;               reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    IF              reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    !               reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    BREAK           reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    CONTINUE        reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    -               reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    NUMBER          reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    TRUE            reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    FALSE           reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    STRING          reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    ID              reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    (               reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    $end            reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    }               reduce using rule 5 (if -> IF ( expr ) com ELSE com .)
    ELSE            reduce using rule 5 (if -> IF ( expr ) com ELSE com .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for * in state 100 resolved as shift
WARNING: shift/reduce conflict for / in state 100 resolved as shift
WARNING: shift/reduce conflict for % in state 100 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 115 resolved as shift
